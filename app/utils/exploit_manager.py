"""
Exploit Manager Core Logic
Handles exploit data management, searching, filtering, and operations.
"""

import json
import os
from datetime import datetime
from typing import List, Dict, Optional, Callable
from exploit_executor import ExploitExecutor


class ExploitManagerCore:
    """Core logic for exploit management"""
    
    def __init__(self):
        self.exploits_data: List[Dict] = []
        self.filtered_exploits: List[Dict] = []
        self.selected_exploit: Optional[Dict] = None
        self.reports_dir = "app/data/reports"
        self.exploits_db_path = "app/data/exploits/exploits_database.json"
        self.executor = ExploitExecutor()
        self._ensure_directories()
        
    def _ensure_directories(self):
        """Ensure required directories exist"""
        os.makedirs(self.reports_dir, exist_ok=True)
        os.makedirs(os.path.dirname(self.exploits_db_path), exist_ok=True)
    
    def load_initial_exploits(self) -> List[Dict]:
        """Load exploits from database file"""
        try:
            if os.path.exists(self.exploits_db_path):
                with open(self.exploits_db_path, 'r') as f:
                    db_data = json.load(f)
                    exploits = db_data.get('exploits', [])
            else:
                # Fallback to empty list if database doesn't exist
                exploits = []
            
            self.exploits_data = exploits
            self.filtered_exploits = exploits.copy()
            return exploits
            
        except Exception as e:
            print(f"Error loading exploits database: {e}")
            self.exploits_data = []
            self.filtered_exploits = []
            return []
    
    def filter_exploits(self, search_term: str = "", platform: str = "All", severity: str = "All") -> List[Dict]:
        """Filter exploits based on search criteria"""
        search_term = search_term.lower()
        filtered = []
        
        for exploit in self.exploits_data:
            # Check search term
            if search_term and search_term not in exploit["name"].lower() and search_term not in exploit["cve_id"].lower():
                continue
            
            # Check platform
            if platform != "All" and exploit["platform"] != platform:
                continue
            
            # Check severity
            if severity != "All" and exploit["severity"] != severity:
                continue
            
            filtered.append(exploit)
        
        self.filtered_exploits = filtered
        return filtered
    
    def get_exploit_by_cve(self, cve_id: str) -> Optional[Dict]:
        """Get exploit details by CVE ID"""
        return next((e for e in self.exploits_data if e["cve_id"] == cve_id), None)
    
    def set_selected_exploit(self, cve_id: str) -> Optional[Dict]:
        """Set the currently selected exploit"""
        self.selected_exploit = self.get_exploit_by_cve(cve_id)
        return self.selected_exploit
    
    def format_exploit_details(self, exploit: Dict) -> str:
        """Format exploit details for display"""
        if not exploit:
            return ""
        
        details = f"""CVE ID: {exploit['cve_id']}
Name: {exploit['name']}
Platform: {exploit['platform']}
Severity: {exploit['severity']}
CVSS Score: {exploit.get('cvss_score', 'N/A')}
Date: {exploit['date']}
Exploit Available: {'Yes' if exploit.get('exploit_available', False) else 'No'}
Metasploit Module: {exploit.get('metasploit_module', 'N/A')}

Description:
{exploit['description']}

References:
"""
        for ref in exploit.get('references', []):
            details += f"â€¢ {ref}\n"
        
        return details
    
    def save_exploit_to_file(self, exploit: Dict) -> str:
        """Save exploit to local JSON file"""
        if not exploit:
            raise ValueError("No exploit provided")
        
        filename = f"{self.reports_dir}/exploit_{exploit['cve_id'].replace('-', '_')}.json"
        
        # Add metadata
        exploit_with_metadata = exploit.copy()
        exploit_with_metadata['saved_date'] = datetime.now().isoformat()
        exploit_with_metadata['saved_by'] = 'PenTest MultiTools'
        
        with open(filename, 'w') as f:
            json.dump(exploit_with_metadata, f, indent=2)
        
        return filename
    
    def load_local_exploits(self) -> tuple[List[Dict], int]:
        """Load exploits from local files"""
        if not os.path.exists(self.reports_dir):
            return [], 0
        
        loaded_exploits = []
        loaded_count = 0
        
        for filename in os.listdir(self.reports_dir):
            if filename.startswith("exploit_") and filename.endswith(".json"):
                try:
                    with open(os.path.join(self.reports_dir, filename), 'r') as f:
                        exploit_data = json.load(f)
                    
                    # Check if exploit already exists
                    if not any(e["cve_id"] == exploit_data["cve_id"] for e in self.exploits_data):
                        self.exploits_data.append(exploit_data)
                        loaded_exploits.append(exploit_data)
                        loaded_count += 1
                        
                except Exception as e:
                    print(f"Error loading {filename}: {e}")
        
        # Update filtered list
        self.filtered_exploits = self.exploits_data.copy()
        return loaded_exploits, loaded_count
    
    def execute_exploit(self, exploit: Dict, target_config: Dict, progress_callback: Optional[Callable] = None) -> Dict:
        """Execute real exploit against target"""
        if not exploit:
            raise ValueError("No exploit selected")
        
        if not target_config:
            raise ValueError("No target configuration provided")
        
        try:
            # Determine target type and execute accordingly
            target_type = target_config.get("type", "web").lower()
            
            if target_type == "web":
                target_url = target_config.get("url")
                if not target_url:
                    raise ValueError("Target URL not provided for web exploit")
                
                return self.executor.execute_web_exploit(exploit, target_url, progress_callback)
            
            elif target_type == "network":
                target_ip = target_config.get("ip")
                target_port = target_config.get("port")
                
                if not target_ip:
                    raise ValueError("Target IP not provided for network exploit")
                
                return self.executor.execute_network_exploit(exploit, target_ip, target_port, progress_callback)
            
            else:
                raise ValueError(f"Unsupported target type: {target_type}")
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "cve_id": exploit.get("cve_id", "Unknown"),
                "target": target_config.get("name", "Unknown")
            }
    
    def _get_payload_type(self, exploit: Dict) -> str:
        """Determine payload type based on platform and exploit"""
        platform = exploit.get("platform", "").lower()
        if platform == "web":
            return "web_shell"
        elif platform == "windows":
            return "windows/meterpreter/reverse_tcp"
        elif platform == "linux":
            return "linux/x64/meterpreter/reverse_tcp"
        else:
            return "generic/shell_reverse_tcp"
    
    def get_platforms(self) -> List[str]:
        """Get list of available platforms"""
        platforms = set(exploit["platform"] for exploit in self.exploits_data)
        return ["All"] + sorted(platforms)
    
    def get_severities(self) -> List[str]:
        """Get list of available severities"""
        return ["All", "Critical", "High", "Medium", "Low"]
    
    def get_exploit_stats(self) -> Dict[str, int]:
        """Get statistics about loaded exploits"""
        stats = {
            "total": len(self.exploits_data),
            "critical": len([e for e in self.exploits_data if e["severity"] == "Critical"]),
            "high": len([e for e in self.exploits_data if e["severity"] == "High"]),
            "medium": len([e for e in self.exploits_data if e["severity"] == "Medium"]),
            "low": len([e for e in self.exploits_data if e["severity"] == "Low"]),
            "with_exploits": len([e for e in self.exploits_data if e.get("exploit_available", False)]),
            "platforms": len(set(e["platform"] for e in self.exploits_data))
        }
        return stats
    
    def get_database_info(self) -> Dict:
        """Get information about the exploit database"""
        try:
            if os.path.exists(self.exploits_db_path):
                with open(self.exploits_db_path, 'r') as f:
                    db_data = json.load(f)
                    return db_data.get('metadata', {})
            return {}
        except Exception:
            return {}
    
    def create_target_config(self, name: str, target_type: str, **kwargs) -> Dict:
        """Create a target configuration"""
        return self.executor.create_target_config(name, target_type, **kwargs)
    
    def get_saved_targets(self) -> List[Dict]:
        """Get list of saved target configurations"""
        return self.executor.get_saved_targets()
    
    def validate_target(self, target_ip: str, target_port: int = None) -> Dict:
        """Validate target accessibility"""
        return self.executor.validate_target(target_ip, target_port)
    
    def simulate_cve_download(self, progress_callback: Optional[Callable] = None) -> Dict:
        """Simulate downloading CVE data from external sources"""
        download_steps = [
            "Connecting to NVD database...",
            "Downloading CVE feeds...",
            "Parsing vulnerability data...",
            "Updating local database...",
            "Download completed!"
        ]
        
        if progress_callback:
            import time
            for i, step in enumerate(download_steps):
                progress_callback(i + 1, len(download_steps), step)
                time.sleep(0.6)
        
        # Simulate adding a few new CVEs
        new_count = 3
        current_year = datetime.now().year
        
        for i in range(new_count):
            new_cve_id = f"CVE-{current_year}-{50000 + i}"
            if not any(e["cve_id"] == new_cve_id for e in self.exploits_data):
                new_cve = {
                    "cve_id": new_cve_id,
                    "name": f"Simulated Vulnerability {i+1}",
                    "platform": ["Web", "Windows", "Linux"][i % 3],
                    "severity": ["High", "Medium", "Critical"][i % 3],
                    "date": datetime.now().strftime("%Y-%m-%d"),
                    "description": f"This is a simulated CVE downloaded from NVD database for testing purposes.",
                    "cvss_score": str(round(7.0 + i * 0.5, 1)),
                    "references": [f"https://nvd.nist.gov/vuln/detail/{new_cve_id}"],
                    "exploit_available": False,
                    "metasploit_module": None,
                    "affected_versions": ["Various"],
                    "tags": ["simulated", "testing"]
                }
                self.exploits_data.append(new_cve)
        
        self.filtered_exploits = self.exploits_data.copy()
        
        return {
            "success": True,
            "downloaded": new_count,
            "total_cves": len(self.exploits_data)
        }
    
    def export_exploits(self, filename: str = None) -> str:
        """Export all exploits to JSON file"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{self.reports_dir}/exploits_export_{timestamp}.json"
        
        export_data = {
            "export_date": datetime.now().isoformat(),
            "total_exploits": len(self.exploits_data),
            "exported_by": "PenTest MultiTools",
            "exploits": self.exploits_data
        }
        
        with open(filename, 'w') as f:
            json.dump(export_data, f, indent=2)
        
        return filename
    
    def validate_exploit_data(self, exploit: Dict) -> tuple[bool, List[str]]:
        """Validate exploit data structure"""
        errors = []
        required_fields = ["cve_id", "name", "platform", "severity", "date", "description"]
        
        for field in required_fields:
            if field not in exploit:
                errors.append(f"Missing required field: {field}")
        
        # Validate CVE ID format
        if "cve_id" in exploit and not exploit["cve_id"].startswith("CVE-"):
            errors.append("Invalid CVE ID format")
        
        # Validate severity
        valid_severities = ["Critical", "High", "Medium", "Low"]
        if "severity" in exploit and exploit["severity"] not in valid_severities:
            errors.append(f"Invalid severity. Must be one of: {', '.join(valid_severities)}")
        
        return len(errors) == 0, errors