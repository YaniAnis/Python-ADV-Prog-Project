import ttkbootstrap as tb
from ttkbootstrap.constants import *
import threading
import sys
import os
from tkinter import messagebox

# Add utils to path
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'utils'))
from exploit_manager import ExploitManagerCore

class ExploitManager:
    def __init__(self, master):
        self.window = tb.Toplevel(master)
        self.window.title("Exploit Manager")
        self.window.geometry("1000x700")
        try:
            self.window.iconbitmap("app/assets/logo-tete-de-mort-png.ico")
        except Exception:
            pass
        self.window.resizable(True, True)
        
        # Initialize core logic
        self.core = ExploitManagerCore()
        self.is_scanning = False
        
        self.setup_ui()
        self.load_exploits()

    def setup_ui(self):
        # Title and close button
        title_frame = tb.Frame(self.window)
        title_frame.pack(fill=X, padx=10, pady=5)
        
        tb.Label(
            title_frame,
            text="üõ°Ô∏è Exploit Manager",
            font=("Helvetica", 16, "bold"),
            bootstyle="info"
        ).pack(side=LEFT)
        
        tb.Button(
            title_frame,
            text="Fermer",
            bootstyle="danger-outline",
            command=self.window.destroy
        ).pack(side=RIGHT)

        # Main container
        main_frame = tb.Frame(self.window)
        main_frame.pack(fill=BOTH, expand=True, padx=10, pady=5)

        # Left panel - Search and filters
        left_frame = tb.LabelFrame(main_frame, text="üîç Search & Filters", padding=10)
        left_frame.pack(side=LEFT, fill=Y, padx=(0, 5))

        # Search section
        search_frame = tb.Frame(left_frame)
        search_frame.pack(fill=X, pady=(0, 10))

        tb.Label(search_frame, text="Search Term:").pack(anchor=W)
        self.search_var = tb.StringVar()
        self.search_entry = tb.Entry(
            search_frame,
            textvariable=self.search_var,
            width=30
        )
        self.search_entry.pack(fill=X, pady=(2, 5))
        self.search_entry.bind('<KeyRelease>', self.on_search_change)

        # Platform filter
        tb.Label(search_frame, text="Platform:").pack(anchor=W)
        self.platform_var = tb.StringVar(value="All")
        platform_combo = tb.Combobox(
            search_frame,
            textvariable=self.platform_var,
            values=["All", "Windows", "Linux", "MacOS", "Web", "Android", "iOS"],
            state="readonly",
            width=27
        )
        platform_combo.pack(fill=X, pady=(2, 5))
        platform_combo.bind('<<ComboboxSelected>>', self.filter_exploits)

        # Severity filter
        tb.Label(search_frame, text="Severity:").pack(anchor=W)
        self.severity_var = tb.StringVar(value="All")
        severity_combo = tb.Combobox(
            search_frame,
            textvariable=self.severity_var,
            values=["All", "Critical", "High", "Medium", "Low"],
            state="readonly",
            width=27
        )
        severity_combo.pack(fill=X, pady=(2, 5))
        severity_combo.bind('<<ComboboxSelected>>', self.filter_exploits)

        # Action buttons
        btn_frame = tb.Frame(left_frame)
        btn_frame.pack(fill=X, pady=(10, 0))

        tb.Button(
            btn_frame,
            text="üîÑ Refresh DB",
            bootstyle="primary",
            command=self.refresh_exploits
        ).pack(fill=X, pady=(0, 5))

        tb.Button(
            btn_frame,
            text="üì• Load Local",
            bootstyle="secondary",
            command=self.load_local_exploits
        ).pack(fill=X, pady=(0, 5))

        tb.Button(
            btn_frame,
            text="üåê Download CVE",
            bootstyle="info",
            command=self.download_cve_data
        ).pack(fill=X, pady=(0, 5))

        # Right panel - Exploits list and details
        right_frame = tb.Frame(main_frame)
        right_frame.pack(side=RIGHT, fill=BOTH, expand=True)

        # Exploits list
        list_frame = tb.LabelFrame(right_frame, text="üìã Available Exploits", padding=10)
        list_frame.pack(fill=BOTH, expand=True, pady=(0, 5))

        # Treeview for exploits
        columns = ("ID", "Name", "Platform", "Severity", "Date")
        self.exploits_tree = tb.Treeview(
            list_frame,
            columns=columns,
            show="tree headings",
            height=15
        )
        
        # Configure columns
        self.exploits_tree.heading("#0", text="CVE-ID", anchor=W)
        self.exploits_tree.column("#0", width=120, minwidth=100)
        
        for col in columns:
            self.exploits_tree.heading(col, text=col, anchor=W)
            self.exploits_tree.column(col, width=100, minwidth=80)

        # Scrollbars
        v_scroll = tb.Scrollbar(list_frame, orient=VERTICAL, command=self.exploits_tree.yview)
        h_scroll = tb.Scrollbar(list_frame, orient=HORIZONTAL, command=self.exploits_tree.xview)
        self.exploits_tree.configure(yscrollcommand=v_scroll.set, xscrollcommand=h_scroll.set)

        # Pack treeview and scrollbars
        self.exploits_tree.pack(side=LEFT, fill=BOTH, expand=True)
        v_scroll.pack(side=RIGHT, fill=Y)
        h_scroll.pack(side=BOTTOM, fill=X)

        # Bind selection event
        self.exploits_tree.bind('<<TreeviewSelect>>', self.on_exploit_select)

        # Exploit details panel
        details_frame = tb.LabelFrame(right_frame, text="üìÑ Exploit Details", padding=10)
        details_frame.pack(fill=X)

        # Details text widget
        self.details_text = tb.Text(
            details_frame,
            height=8,
            wrap=WORD,
            state=DISABLED
        )
        details_scroll = tb.Scrollbar(details_frame, orient=VERTICAL, command=self.details_text.yview)
        self.details_text.configure(yscrollcommand=details_scroll.set)
        
        self.details_text.pack(side=LEFT, fill=BOTH, expand=True)
        details_scroll.pack(side=RIGHT, fill=Y)

        # Target configuration frame
        target_config_frame = tb.LabelFrame(details_frame, text="üéØ Target Configuration", padding=5)
        target_config_frame.pack(fill=X, pady=(10, 0))

        # Target type selection
        target_type_frame = tb.Frame(target_config_frame)
        target_type_frame.pack(fill=X)

        tb.Label(target_type_frame, text="Target Type:").pack(side=LEFT)
        self.target_type_var = tb.StringVar(value="web")
        target_type_combo = tb.Combobox(
            target_type_frame,
            textvariable=self.target_type_var,
            values=["web", "network"],
            state="readonly",
            width=15
        )
        target_type_combo.pack(side=LEFT, padx=(5, 10))
        target_type_combo.bind('<<ComboboxSelected>>', self.on_target_type_change)

        # Target input fields
        target_input_frame = tb.Frame(target_config_frame)
        target_input_frame.pack(fill=X, pady=(5, 0))

        # URL/IP input
        tb.Label(target_input_frame, text="Target:").pack(side=LEFT)
        self.target_input_var = tb.StringVar()
        self.target_input = tb.Entry(
            target_input_frame,
            textvariable=self.target_input_var,
            width=30
        )
        self.target_input.pack(side=LEFT, padx=(5, 10))

        # Port input (for network targets)
        self.port_label = tb.Label(target_input_frame, text="Port:")
        self.port_var = tb.StringVar()
        self.port_input = tb.Entry(
            target_input_frame,
            textvariable=self.port_var,
            width=8
        )

        # Validate button
        self.validate_btn = tb.Button(
            target_input_frame,
            text="üîç Validate",
            bootstyle="info-outline",
            command=self.validate_target
        )
        self.validate_btn.pack(side=RIGHT)

        # Action buttons for selected exploit
        action_frame = tb.Frame(details_frame)
        action_frame.pack(fill=X, pady=(10, 0))

        self.execute_btn = tb.Button(
            action_frame,
            text="‚ö° Execute Exploit",
            bootstyle="warning",
            command=self.execute_exploit,
            state=DISABLED
        )
        self.execute_btn.pack(side=LEFT, padx=(0, 5))

        self.info_btn = tb.Button(
            action_frame,
            text="‚ÑπÔ∏è More Info",
            bootstyle="info-outline",
            command=self.show_more_info,
            state=DISABLED
        )
        self.info_btn.pack(side=LEFT, padx=(0, 5))

        self.save_btn = tb.Button(
            action_frame,
            text="üíæ Save Exploit",
            bootstyle="success-outline",
            command=self.save_exploit,
            state=DISABLED
        )
        self.save_btn.pack(side=LEFT, padx=(0, 5))

        self.targets_btn = tb.Button(
            action_frame,
            text="üéØ Manage Targets",
            bootstyle="secondary-outline",
            command=self.manage_targets
        )
        self.targets_btn.pack(side=LEFT)

        # Status bar
        self.status_var = tb.StringVar(value="Ready")
        status_bar = tb.Label(
            self.window,
            textvariable=self.status_var,
            relief=SUNKEN,
            anchor=W
        )
        status_bar.pack(side=BOTTOM, fill=X)

    def load_exploits(self):
        """Load initial exploit data"""
        self.status_var.set("Loading exploits...")
        
        # Load exploits using core logic
        exploits = self.core.load_initial_exploits()
        self.populate_exploits_tree()
        
        # Update platform and severity filters
        self.update_filter_options()
        
        stats = self.core.get_exploit_stats()
        self.status_var.set(f"Loaded {stats['total']} exploits ({stats['critical']} critical, {stats['high']} high)")

    def populate_exploits_tree(self, exploits=None):
        """Populate the exploits treeview"""
        # Clear existing items
        for item in self.exploits_tree.get_children():
            self.exploits_tree.delete(item)
        
        if exploits is None:
            exploits = self.core.filtered_exploits
        
        for exploit in exploits:
            self.exploits_tree.insert(
                "",
                "end",
                text=exploit["cve_id"],
                values=(
                    exploit["cve_id"],
                    exploit["name"][:50] + "..." if len(exploit["name"]) > 50 else exploit["name"],
                    exploit["platform"],
                    exploit["severity"],
                    exploit["date"]
                ),
                tags=(exploit["severity"].lower(),)
            )
        
        # Configure tags for severity colors
        self.exploits_tree.tag_configure("critical", background="#ffebee")
        self.exploits_tree.tag_configure("high", background="#fff3e0")
        self.exploits_tree.tag_configure("medium", background="#f3e5f5")
        self.exploits_tree.tag_configure("low", background="#e8f5e8")

    def update_filter_options(self):
        """Update filter dropdown options based on loaded data"""
        # Update platform filter
        platforms = self.core.get_platforms()
        platform_combo = None
        for child in self.window.winfo_children():
            if hasattr(child, 'winfo_children'):
                for subchild in child.winfo_children():
                    if hasattr(subchild, 'winfo_children'):
                        for widget in subchild.winfo_children():
                            if isinstance(widget, tb.Combobox) and 'platform' in str(widget):
                                platform_combo = widget
                                break
        
        if platform_combo:
            platform_combo.configure(values=platforms)

    def on_search_change(self, event=None):
        """Handle search input changes"""
        self.filter_exploits()

    def filter_exploits(self, event=None):
        """Filter exploits based on search criteria"""
        search_term = self.search_var.get()
        platform = self.platform_var.get()
        severity = self.severity_var.get()
        
        # Use core logic for filtering
        filtered_exploits = self.core.filter_exploits(search_term, platform, severity)
        self.populate_exploits_tree(filtered_exploits)
        
        stats = self.core.get_exploit_stats()
        self.status_var.set(f"Showing {len(filtered_exploits)} of {stats['total']} exploits")

    def on_exploit_select(self, event=None):
        """Handle exploit selection"""
        selection = self.exploits_tree.selection()
        if not selection:
            self.core.selected_exploit = None
            self.update_details("")
            self.execute_btn.config(state=DISABLED)
            self.info_btn.config(state=DISABLED)
            self.save_btn.config(state=DISABLED)
            return
        
        # Get selected item
        item = self.exploits_tree.item(selection[0])
        cve_id = item["text"]
        
        # Use core logic to set selected exploit
        selected_exploit = self.core.set_selected_exploit(cve_id)
        
        if selected_exploit:
            self.update_details(self.core.format_exploit_details(selected_exploit))
            self.execute_btn.config(state=NORMAL)
            self.info_btn.config(state=NORMAL)
            self.save_btn.config(state=NORMAL)

    def update_details(self, text):
        """Update the details text widget"""
        self.details_text.config(state=NORMAL)
        self.details_text.delete(1.0, END)
        self.details_text.insert(1.0, text)
        self.details_text.config(state=DISABLED)

    def on_target_type_change(self, event=None):
        """Handle target type selection change"""
        target_type = self.target_type_var.get()
        
        if target_type == "network":
            # Show port input for network targets
            self.port_label.pack(side=LEFT, padx=(10, 5))
            self.port_input.pack(side=LEFT, padx=(0, 10))
            self.target_input_var.set("")  # Clear placeholder
            
        else:
            # Hide port input for web targets
            self.port_label.pack_forget()
            self.port_input.pack_forget()
            self.target_input_var.set("http://")  # Set placeholder for URL

    def validate_target(self):
        """Validate the target configuration"""
        target_input = self.target_input_var.get().strip()
        target_type = self.target_type_var.get()
        
        if not target_input:
            messagebox.showwarning("Invalid Target", "Please enter a target URL or IP address.")
            return
        
        self.status_var.set("Validating target...")
        self.validate_btn.config(state=DISABLED, text="Validating...")
        
        def validate_thread():
            try:
                if target_type == "web":
                    # Basic URL validation
                    if not target_input.startswith(('http://', 'https://')):
                        result = {"reachable": False, "error": "URL must start with http:// or https://"}
                    else:
                        import requests
                        try:
                            response = requests.get(target_input, timeout=10, verify=False)
                            result = {
                                "reachable": True,
                                "status_code": response.status_code,
                                "server": response.headers.get("Server", "Unknown")
                            }
                        except Exception as e:
                            result = {"reachable": False, "error": str(e)}
                
                else:  # network
                    port = None
                    if self.port_var.get():
                        try:
                            port = int(self.port_var.get())
                        except ValueError:
                            result = {"reachable": False, "error": "Invalid port number"}
                            self.window.after(0, lambda: self.validation_complete(result))
                            return
                    
                    result = self.core.validate_target(target_input, port)
                
                self.window.after(0, lambda: self.validation_complete(result))
                
            except Exception as e:
                self.window.after(0, lambda: self.validation_error(str(e)))
        
        threading.Thread(target=validate_thread, daemon=True).start()

    def validation_complete(self, result):
        """Handle target validation completion"""
        self.validate_btn.config(state=NORMAL, text="üîç Validate")
        
        if result.get("reachable"):
            self.status_var.set("Target validation successful")
            messagebox.showinfo(
                "Target Valid", 
                f"Target is reachable!\n\n"
                f"Details: {result}"
            )
        else:
            self.status_var.set("Target validation failed")
            messagebox.showwarning(
                "Target Unreachable", 
                f"Could not reach target:\n{result.get('error', 'Unknown error')}"
            )

    def validation_error(self, error_msg):
        """Handle validation error"""
        self.validate_btn.config(state=NORMAL, text="üîç Validate")
        self.status_var.set("Target validation error")
        messagebox.showerror("Validation Error", f"Error validating target:\n{error_msg}")

    def execute_exploit(self):
        """Execute the selected exploit against the configured target"""
        if not self.core.selected_exploit:
            messagebox.showwarning("No Exploit", "Please select an exploit first.")
            return
        
        target_input = self.target_input_var.get().strip()
        target_type = self.target_type_var.get()
        
        if not target_input:
            messagebox.showwarning("No Target", "Please configure a target first.")
            return
        
        # Create target configuration
        target_config = {"type": target_type}
        
        if target_type == "web":
            if not target_input.startswith(('http://', 'https://')):
                messagebox.showwarning("Invalid URL", "URL must start with http:// or https://")
                return
            target_config["url"] = target_input
            
        else:  # network
            target_config["ip"] = target_input
            if self.port_var.get():
                try:
                    target_config["port"] = int(self.port_var.get())
                except ValueError:
                    messagebox.showwarning("Invalid Port", "Please enter a valid port number.")
                    return
        
        # Show confirmation dialog
        result = messagebox.askyesno(
            "Confirm Exploit Execution",
            f"Are you sure you want to execute exploit {self.core.selected_exploit['cve_id']} against:\n\n"
            f"Target: {target_input}\n"
            f"Type: {target_type.upper()}\n\n"
            "‚ö†Ô∏è WARNING: This will perform REAL exploit attempts!\n"
            "‚ö†Ô∏è Only use on systems you own or have explicit permission to test.\n"
            "‚ö†Ô∏è Unauthorized access to computer systems is illegal!"
        )
        
        if not result:
            return
        
        # Start exploit execution
        self.status_var.set("Executing exploit...")
        self.execute_btn.config(state=DISABLED, text="Executing...")
        
        def progress_callback(current, total, step):
            """Update progress in UI thread"""
            def update_ui():
                progress = int((current / total) * 100)
                self.status_var.set(f"Executing exploit... {progress}% - {step}")
            self.window.after(0, update_ui)
        
        def execute_thread():
            try:
                # Use core logic for real execution
                results = self.core.execute_exploit(
                    self.core.selected_exploit,
                    target_config,
                    progress_callback
                )
                # Update UI in main thread
                self.window.after(0, lambda: self.execution_complete(results))
            except Exception as e:
                self.window.after(0, lambda: self.execution_error(str(e)))
        
        threading.Thread(target=execute_thread, daemon=True).start()

    def execution_complete(self, results):
        """Handle exploit execution completion"""
        self.execute_btn.config(state=NORMAL, text="‚ö° Execute Exploit")
        
        if results.get('success'):
            self.status_var.set("‚úÖ Exploit execution successful!")
        else:
            self.status_var.set("‚ùå Exploit execution failed")
        
        # Create detailed results window
        results_window = tb.Toplevel(self.window)
        results_window.title(f"Exploit Results - {results.get('cve_id', 'Unknown')}")
        results_window.geometry("700x600")
        
        # Results text widget
        text_frame = tb.Frame(results_window)
        text_frame.pack(fill=BOTH, expand=True, padx=10, pady=10)
        
        text_widget = tb.Text(text_frame, wrap=WORD, font=("Consolas", 10))
        scrollbar = tb.Scrollbar(text_frame, orient=VERTICAL, command=text_widget.yview)
        text_widget.configure(yscrollcommand=scrollbar.set)
        
        # Format results for display
        result_text = f"""üéØ EXPLOIT EXECUTION RESULTS
{'='*50}

CVE ID: {results.get('cve_id', 'Unknown')}
Status: {'‚úÖ SUCCESS' if results.get('success') else '‚ùå FAILED'}
Target: {results.get('target', 'Unknown')}
Method: {results.get('method', 'Unknown')}

"""
        
        # Add specific result details
        if 'payload' in results:
            result_text += f"Payload: {results['payload']}\n"
        if 'command_executed' in results:
            result_text += f"Command: {results['command_executed']}\n"
        if 'response' in results:
            result_text += f"Response: {results['response']}\n"
        if 'webshell_url' in results:
            result_text += f"Webshell URL: {results['webshell_url']}\n"
        if 'open_ports' in results:
            result_text += f"Open Ports: {results['open_ports']}\n"
        if 'issues_found' in results:
            result_text += f"\nSecurity Issues Found:\n"
            for issue in results['issues_found']:
                result_text += f"‚Ä¢ {issue}\n"
        
        result_text += f"\nüìù NOTES:\n"
        result_text += f"{results.get('note', 'No additional notes')}\n"
        
        if 'recommendation' in results:
            result_text += f"\nüí° RECOMMENDATION:\n"
            result_text += f"{results['recommendation']}\n"
        
        # Add warnings if any
        if 'warnings' in results:
            result_text += f"\n‚ö†Ô∏è WARNINGS:\n"
            for warning in results['warnings']:
                result_text += f"‚Ä¢ {warning}\n"
        
        # Add error if failed
        if 'error' in results:
            result_text += f"\n‚ùå ERROR:\n{results['error']}\n"
        
        result_text += f"\n{'='*50}\n"
        result_text += f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        
        text_widget.insert(1.0, result_text)
        text_widget.config(state=DISABLED)
        
        text_widget.pack(side=LEFT, fill=BOTH, expand=True)
        scrollbar.pack(side=RIGHT, fill=Y)
        
        # Buttons
        btn_frame = tb.Frame(results_window)
        btn_frame.pack(fill=X, padx=10, pady=5)
        
        tb.Button(
            btn_frame,
            text="üìã Copy Results",
            bootstyle="info",
            command=lambda: self.copy_to_clipboard(result_text)
        ).pack(side=LEFT, padx=(0, 5))
        
        tb.Button(
            btn_frame,
            text="üíæ Save Report",
            bootstyle="success",
            command=lambda: self.save_exploit_report(results, result_text)
        ).pack(side=LEFT, padx=(0, 5))
        
        tb.Button(
            btn_frame,
            text="Close",
            bootstyle="secondary",
            command=results_window.destroy
        ).pack(side=RIGHT)

    def copy_to_clipboard(self, text):
        """Copy text to clipboard"""
        try:
            self.window.clipboard_clear()
            self.window.clipboard_append(text)
            messagebox.showinfo("Copied", "Results copied to clipboard!")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to copy to clipboard: {e}")

    def save_exploit_report(self, results, formatted_text):
        """Save exploit execution report"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"{self.core.reports_dir}/exploit_report_{results.get('cve_id', 'unknown').replace('-', '_')}_{timestamp}.txt"
            
            with open(filename, 'w') as f:
                f.write(formatted_text)
            
            messagebox.showinfo("Report Saved", f"Exploit report saved to:\n{filename}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save report: {e}")
    
    def execution_error(self, error_msg):
        """Handle exploit execution error"""
        self.execute_btn.config(state=NORMAL, text="‚ö° Execute Exploit")
        self.status_var.set("Exploit execution failed")
        messagebox.showerror("Execution Error", f"Failed to execute exploit:\n{error_msg}")

    def show_more_info(self):
        """Show more detailed information about the selected exploit"""
        if not self.core.selected_exploit:
            return
        
        info_window = tb.Toplevel(self.window)
        info_window.title(f"Exploit Info - {self.core.selected_exploit['cve_id']}")
        info_window.geometry("600x500")
        
        # Create text widget with scrollbar
        text_frame = tb.Frame(info_window)
        text_frame.pack(fill=BOTH, expand=True, padx=10, pady=10)
        
        text_widget = tb.Text(text_frame, wrap=WORD)
        scrollbar = tb.Scrollbar(text_frame, orient=VERTICAL, command=text_widget.yview)
        text_widget.configure(yscrollcommand=scrollbar.set)
        
        # Add detailed information using core logic
        detailed_info = self.core.format_exploit_details(self.core.selected_exploit)
        detailed_info += "\n\nAdditional Information:\n"
        detailed_info += "‚Ä¢ This is a simulated environment\n"
        detailed_info += "‚Ä¢ Real exploit code would be loaded from external sources\n"
        detailed_info += "‚Ä¢ Always ensure you have permission before testing\n"
        
        text_widget.insert(1.0, detailed_info)
        text_widget.config(state=DISABLED)
        
        text_widget.pack(side=LEFT, fill=BOTH, expand=True)
        scrollbar.pack(side=RIGHT, fill=Y)
        
        # Close button
        tb.Button(
            info_window,
            text="Close",
            bootstyle="primary",
            command=info_window.destroy
        ).pack(pady=10)

    def save_exploit(self):
        """Save exploit to local collection"""
        if not self.core.selected_exploit:
            return
        
        try:
            # Use core logic to save exploit
            filename = self.core.save_exploit_to_file(self.core.selected_exploit)
            
            messagebox.showinfo(
                "Exploit Saved",
                f"Exploit {self.core.selected_exploit['cve_id']} has been saved to:\n{filename}"
            )
            self.status_var.set(f"Exploit saved to {os.path.basename(filename)}")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save exploit: {str(e)}")

    def refresh_exploits(self):
        """Refresh exploit database"""
        self.status_var.set("Refreshing exploit database...")
        
        def refresh_thread():
            import time
            time.sleep(2)  # Simulate refresh time
            self.window.after(0, self.refresh_complete)
        
        threading.Thread(target=refresh_thread, daemon=True).start()

    def refresh_complete(self):
        """Complete the refresh operation"""
        # In a real implementation, this would fetch new data
        self.load_exploits()
        messagebox.showinfo("Refresh Complete", "Exploit database has been refreshed!")

    def load_local_exploits(self):
        """Load exploits from local files"""
        try:
            # Use core logic to load local exploits
            loaded_exploits, loaded_count = self.core.load_local_exploits()
            
            if loaded_count == 0:
                messagebox.showinfo("No Local Exploits", "No new local exploit files found.")
                return
            
            self.populate_exploits_tree()
            messagebox.showinfo(
                "Local Exploits Loaded",
                f"Loaded {loaded_count} new exploits from local files."
            )
            self.status_var.set(f"Loaded {loaded_count} local exploits")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load local exploits: {str(e)}")

    def download_cve_data(self):
        """Download CVE data from external sources (simulation)"""
        result = messagebox.askyesno(
            "Download CVE Data",
            "This will attempt to download the latest CVE data.\n"
            "This may take some time. Continue?"
        )
        
        if not result:
            return
        
        self.status_var.set("Downloading CVE data...")
        
        def progress_callback(current, total, step):
            """Update progress in UI thread"""
            def update_ui():
                progress = int((current / total) * 100)
                self.status_var.set(f"Downloading CVE data... {progress}% - {step}")
            self.window.after(0, update_ui)
        
        def download_thread():
            try:
                # Use core logic for CVE download
                results = self.core.simulate_cve_download(progress_callback)
                self.window.after(0, lambda: self.download_complete(results))
            except Exception as e:
                self.window.after(0, lambda: self.download_error(str(e)))
        
        threading.Thread(target=download_thread, daemon=True).start()

    def download_complete(self, results):
        """Complete the CVE download operation"""
        self.populate_exploits_tree()
        
        messagebox.showinfo(
            "Download Complete", 
            f"CVE data download completed!\n\n"
            f"Downloaded: {results['downloaded']} new CVEs\n"
            f"Total CVEs: {results['total_cves']}\n\n"
            "Note: This is a simulation. In a real implementation,\n"
            "this would connect to CVE databases like NVD."
        )
        self.status_var.set(f"CVE download completed - {results['downloaded']} new CVEs")
    
    def download_error(self, error_msg):
        """Handle CVE download error"""
        self.status_var.set("CVE download failed")
        messagebox.showerror("Download Error", f"Failed to download CVE data:\n{error_msg}")

    def manage_targets(self):
        """Open target management window"""
        targets_window = tb.Toplevel(self.window)
        targets_window.title("Target Management")
        targets_window.geometry("600x500")
        
        # Create new target frame
        create_frame = tb.LabelFrame(targets_window, text="Create New Target", padding=10)
        create_frame.pack(fill=X, padx=10, pady=5)
        
        # Target name
        tb.Label(create_frame, text="Name:").grid(row=0, column=0, sticky=W, pady=2)
        name_var = tb.StringVar()
        tb.Entry(create_frame, textvariable=name_var, width=30).grid(row=0, column=1, padx=5, pady=2)
        
        # Target type
        tb.Label(create_frame, text="Type:").grid(row=1, column=0, sticky=W, pady=2)
        type_var = tb.StringVar(value="web")
        tb.Combobox(create_frame, textvariable=type_var, values=["web", "network"], 
                    state="readonly", width=27).grid(row=1, column=1, padx=5, pady=2)
        
        # Target URL/IP
        tb.Label(create_frame, text="URL/IP:").grid(row=2, column=0, sticky=W, pady=2)
        url_var = tb.StringVar()
        tb.Entry(create_frame, textvariable=url_var, width=30).grid(row=2, column=1, padx=5, pady=2)
        
        # Port (optional)
        tb.Label(create_frame, text="Port (optional):").grid(row=3, column=0, sticky=W, pady=2)
        port_var = tb.StringVar()
        tb.Entry(create_frame, textvariable=port_var, width=30).grid(row=3, column=1, padx=5, pady=2)
        
        def create_target():
            name = name_var.get().strip()
            target_type = type_var.get()
            url_ip = url_var.get().strip()
            port = port_var.get().strip()
            
            if not name or not url_ip:
                messagebox.showwarning("Invalid Input", "Please provide name and URL/IP")
                return
            
            try:
                kwargs = {}
                if target_type == "web":
                    kwargs["url"] = url_ip
                else:
                    kwargs["ip"] = url_ip
                    if port:
                        kwargs["port"] = int(port)
                
                self.core.create_target_config(name, target_type, **kwargs)
                messagebox.showinfo("Success", f"Target '{name}' created successfully!")
                refresh_targets()
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to create target: {e}")
        
        tb.Button(create_frame, text="Create Target", bootstyle="success", 
                 command=create_target).grid(row=4, column=1, pady=10)
        
        # Saved targets frame
        targets_frame = tb.LabelFrame(targets_window, text="Saved Targets", padding=10)
        targets_frame.pack(fill=BOTH, expand=True, padx=10, pady=5)
        
        # Targets listbox
        targets_listbox = tb.Treeview(targets_frame, columns=("Type", "Target"), show="tree headings")
        targets_listbox.heading("#0", text="Name")
        targets_listbox.heading("Type", text="Type")
        targets_listbox.heading("Target", text="Target")
        targets_listbox.pack(fill=BOTH, expand=True)
        
        def refresh_targets():
            targets_listbox.delete(*targets_listbox.get_children())
            targets = self.core.get_saved_targets()
            for target in targets:
                target_info = target.get("url", target.get("ip", "Unknown"))
                if target.get("port"):
                    target_info += f":{target['port']}"
                
                targets_listbox.insert("", "end", text=target["name"], 
                                     values=(target["type"], target_info))
        
        def load_target():
            selection = targets_listbox.selection()
            if not selection:
                messagebox.showwarning("No Selection", "Please select a target")
                return
            
            item = targets_listbox.item(selection[0])
            target_name = item["text"]
            
            # Find the target config
            targets = self.core.get_saved_targets()
            target_config = next((t for t in targets if t["name"] == target_name), None)
            
            if target_config:
                # Load into main window
                self.target_type_var.set(target_config["type"])
                self.on_target_type_change()
                
                if target_config["type"] == "web":
                    self.target_input_var.set(target_config.get("url", ""))
                else:
                    self.target_input_var.set(target_config.get("ip", ""))
                    if target_config.get("port"):
                        self.port_var.set(str(target_config["port"]))
                
                targets_window.destroy()
                messagebox.showinfo("Loaded", f"Target '{target_name}' loaded successfully!")
        
        # Buttons
        btn_frame = tb.Frame(targets_frame)
        btn_frame.pack(fill=X, pady=5)
        
        tb.Button(btn_frame, text="Load Selected", bootstyle="primary", 
                 command=load_target).pack(side=LEFT, padx=5)
        tb.Button(btn_frame, text="Refresh", bootstyle="secondary", 
                 command=refresh_targets).pack(side=LEFT, padx=5)
        
        # Initial load
        refresh_targets()